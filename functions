int socket (int domain, int type, int protocol);

//Эта функция используется для создания сокета.

/***************************************************/

int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen);

//манипулируют флагами, установленными на сокете.

/***************************************************/

int getsockname(int s, struct sockaddr *name, socklen_t *namelen);

//возвращает текущее имя указанного сокета в параметре name.

/***************************************************/

struct protoent *getprotobyname(const char *name);

//возвращает структуру protoent для строки из /etc/protocols, совпадающую с именем протокола name.

/***************************************************/

struct hostent *gethostbyname(const char *name);

//возвращает структуру типа hostent машине с именем name.
//В данном случае name является либо именем машины, либо адресом IPv4 в стандартной точечной нотации,
//либо адресом IPv6 в нотации с двоеточием (и, возможно, точкой) в качестве разделителя
//(см. описание адресов IPv6 в RFC 1884).
//Если name является адресом IPv4 или IPv6, то поиск не производится и gethostbyname()
//просто копирует name в поле h_name, а его эквивалент для структуры struct in_addr копируется
//в поле h_addr_list[0] возвращаемой структуры hostent.
//Если name не оканчивается точкой и установлена переменная окружения HOSTALIASES, то в файле,
//на который указывает HOSTALIASES, будет произведен поиск name (формат файла приведен в hostname(7)).
//Если name не оканчивается точкой, то будет произведен поиск в текущем домене и его родителях.

/***************************************************/

int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);

//Функция getaddrinfo(3) объединяет действия функций getipnodebyname(3), getipnodebyaddr(3), getservbyname(3) и getservbyport(3) в одном интерфейсе.
//Функция getaddrinfo(3) создает одну или несколько структур адресов сокета,
//которые в дальнейшем могут быть использованы в вызовах функций bind(3) или connect(3) для создания сокета клиента или сервера.
//Функция может быть использована с подпроцессами.

/***************************************************/

int bind(int s, char * name, int namelen);

//Эта функция используется сервером для присваивания сокету имени.
//До выполнения функции bind (т.е. присваивания какого-либо имени,
//вид которого зависит от адресного домена ) сокет недоступен программам-клиентам.

/***************************************************/

int connect(int s, char * name, int namelen);

//Функция connect используется процессом-клиентом для установления связи с сервером.

/***************************************************/

int listen(int s, int backlog);

//Функция listen используется сервером, чтобы информировать ОС,
//что он ожидает ("слушает") запросы связи на данном сокете.
//Без такой функции всякое требование связи с этим сокетом будет отвергнуто.

/***************************************************/

int accept(int s, char * name, int* anamelen);

//Эта функция используется сервером для принятия связи на сокет.
//Сокет должен быть уже слушающим в момент вызова функции.

/***************************************************/

uint32_t htonl(uint32_t hostlong);
//преобразует узловой порядок расположения байтов положительного целого hostlong в сетевой порядок расположения байтов.

uint16_t htons(uint16_t hostshort);
//преобразует узловой порядок расположения байтов положительного короткого целого hostshort в сетевой порядок расположения байтов.

uint32_t ntohl(uint32_t netlong);
//преобразует сетевой порядок расположения байтов положительного целого netlong в узловой порядок расположения байтов.

uint16_t ntohs(uint16_t netshort);
//преобразует сетевой порядок расположения байтов положительного короткого целого netshort в узловой порядок расположения байтов.

/***************************************************/

in_addr_t inet_addr(const char *cp);

//преобразует обычный вид IP-адреса cp (из номеров и точек) в двоичный код в сетевом порядке расположения байтов.
//Если входящий адрес неверен, то возвращается INADDR_NONE (обычно -1).
//Это - устаревший способ, поскольку уже существует inet_aton

/***************************************************/

char *inet_ntoa(struct in_addr in);

//преобразует IP-адрес in, заданный в сетевом порядке расположения байтов, в стандартный строчный вид, из номеров и точек.
//Строка располагается в статически размещенном буфере;
//последующие вызовы перепишут его данные.

/***************************************************/

int send(int s, char * buf, int len, int flags);

//Функция служит для записи данных в сокет.

/***************************************************/

int recv(int s, char * buf, int len, int flags);

//Функция служит для чтения данных из сокета.

/***************************************************/

sighandler_t signal(int signum, sighandler_t handler);

//Системный вызов signal() устанавливает новый обработчик сигнала
//с номером signum в соответствии с параметром sighandler,
//который может быть функцией пользователя, SIG_IGN или SIG_DFL.

/***************************************************/

off_t lseek(int fildes, off_t offset, int whence);

//Функция lseek позволяет задавать смещения, которые будут находиться за существующим концом файла (но это не изменяет размер файла).
//Если позднее по этому смещению будут записаны данные, то последующее чтение в промежутке от конца файла до этого смещения,
//будет возвращать нулевые байты (пока в этот промежуток не будут фактически записаны данные).

/***************************************************/

int fstat(int filedes, struct stat *buf);

//Эти функции возвращают информацию об указанном файле.
//Для этого не требуется иметь права доступа к файлу, хотя потребуются права поиска во всех каталогах, указанных в полном имени файла.

/***************************************************/

fcntl - манипуляции с файловым дескриптором

int fcntl(int fd, int cmd);
//Ищет наименьший доступный номер файлового дескриптора, который больше arg и делает его копией дескриптора fd.
//Фактически это другая форма вызова dup2(2) которая используется с явным указанием файлового дескриптора.

int fcntl(int fd, int cmd, long arg);
//Читает флаг close-on-exec.
//Если бит FD_CLOEXEC установлен в 0, то файл будет оставлен открытым при вызове exec, в противном случае он будет закрыт.

int fcntl(int fd, int cmd, struct flock *lock);
//Устанавливает флаг close-on-exec в значение, заданное битом FD_CLOEXEC аргумента arg.

/***************************************************/

int poll(struct pollfd *ufds, unsigned int nfds, int timeout);

//poll является вариантом select. многопоточный синхронный ввод-вывод.
//Функции select и pselect ждут изменения статуса нескольких файловых описателей.
